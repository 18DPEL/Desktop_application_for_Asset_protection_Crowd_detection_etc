"""
Robust RTSP Reader - Production-Grade Stream Handler
=====================================================
A highly resilient RTSP stream reader that exceeds VLC reliability.

Features:
- Multi-backend support (FFmpeg + GStreamer fallback)
- Infinite reconnection with exponential backoff
- TCP/UDP protocol auto-switching
- Stream health monitoring and frozen frame detection
- Thread-safe circular frame buffer
- Comprehensive logging with rotation

Author: AutoGenerated
Version: 1.0.0
"""

import cv2
import time
import threading
import queue
import logging
import os
import hashlib
import numpy as np
from enum import Enum
from dataclasses import dataclass, field
from typing import Optional, Tuple, Callable, Dict, Any
from datetime import datetime
from logging.handlers import RotatingFileHandler
from collections import deque


class ConnectionState(Enum):
    """Connection state machine states."""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    RECONNECTING = "reconnecting"
    ERROR = "error"
    STOPPED = "stopped"


class TransportProtocol(Enum):
    """RTSP transport protocols."""
    UDP = "udp"
    TCP = "tcp"
    HTTP = "http"


class DecodingMode(Enum):
    """Hardware decoding modes."""
    CPU = "cpu"           # Software decoding (FFmpeg/libavcodec)
    GPU = "gpu"           # NVIDIA GPU hardware decoding (NVDEC)
    AUTO = "auto"         # Auto-detect best available


@dataclass
class StreamStats:
    """Real-time stream statistics."""
    fps: float = 0.0
    frames_received: int = 0
    frames_dropped: int = 0
    reconnect_count: int = 0
    last_frame_time: float = 0.0
    connection_uptime: float = 0.0
    bytes_received: int = 0
    avg_frame_decode_time: float = 0.0
    current_state: ConnectionState = ConnectionState.DISCONNECTED
    last_error: str = ""
    backend_used: str = ""
    protocol_used: str = ""
    decoding_mode: str = ""        # cpu/gpu
    gpu_name: str = ""             # GPU device name if using GPU


@dataclass
class RTSPConfig:
    """Configuration for RTSP reader."""
    # Connection settings
    connection_timeout: float = 15.0          # Initial connection timeout (seconds)
    read_timeout: float = 10.0                # Frame read timeout (seconds)
    stale_frame_timeout: float = 5.0          # Frozen stream detection (seconds)
    
    # Reconnection settings
    max_reconnect_delay: float = 60.0         # Maximum backoff delay (seconds)
    initial_reconnect_delay: float = 1.0      # Starting reconnect delay (seconds)
    reconnect_multiplier: float = 2.0         # Exponential backoff multiplier
    infinite_reconnect: bool = True           # Never give up reconnecting
    max_reconnect_attempts: int = 100         # If not infinite, max attempts
    
    # Frame buffer settings
    buffer_size: int = 30                     # Circular buffer size
    drop_frames_when_full: bool = True        # Drop old frames vs block
    
    # Health monitoring
    health_check_interval: float = 2.0        # Health check frequency (seconds)
    max_consecutive_failures: int = 10        # Failures before forced reconnect
    fps_window_size: int = 30                 # Frames for FPS calculation
    
    # Protocol settings
    preferred_protocol: TransportProtocol = TransportProtocol.TCP
    fallback_protocols: list = field(default_factory=lambda: [
        TransportProtocol.UDP, 
        TransportProtocol.HTTP
    ])
    
    # Backend settings (cv2.CAP_FFMPEG, cv2.CAP_GSTREAMER)
    preferred_backend: int = cv2.CAP_FFMPEG
    fallback_backends: list = field(default_factory=lambda: [cv2.CAP_GSTREAMER])
    
    # GPU/CPU Decoding settings
    decoding_mode: DecodingMode = DecodingMode.AUTO  # CPU, GPU, or AUTO
    gpu_device_id: int = 0                           # NVIDIA GPU device ID
    force_gpu: bool = False                          # Fail if GPU not available
    
    # Logging
    log_file: Optional[str] = None
    log_level: int = logging.INFO
    log_max_bytes: int = 10 * 1024 * 1024     # 10MB per log file
    log_backup_count: int = 5                  # Keep 5 backup logs
    
    # Display settings
    show_stats_overlay: bool = True
    window_name: str = "RTSP Stream"


class RobustRTSPReader:
    """
    Production-grade RTSP stream reader with advanced error recovery.
    
    This reader is designed to handle:
    - Network interruptions (WiFi drops, cable disconnects)
    - Camera reboots and firmware updates
    - Stream corruption and decode errors
    - Memory pressure (adaptive buffering)
    - High-latency and unstable connections
    
    Usage:
        reader = RobustRTSPReader("rtsp://camera-ip/stream")
        reader.start()
        
        while True:
            frame = reader.get_frame()
            if frame is not None:
                cv2.imshow("Stream", frame)
            if cv2.waitKey(1) & 0xFF == ord('q'):
                break
        
        reader.stop()
    """
    
    def __init__(self, rtsp_url: str, config: Optional[RTSPConfig] = None,
                 on_connect: Optional[Callable] = None,
                 on_disconnect: Optional[Callable] = None,
                 on_frame: Optional[Callable] = None,
                 on_error: Optional[Callable] = None):
        """
        Initialize the RTSP reader.
        
        Args:
            rtsp_url: RTSP stream URL
            config: Optional RTSPConfig object
            on_connect: Callback when connected
            on_disconnect: Callback when disconnected
            on_frame: Callback for each frame (frame, stats)
            on_error: Callback for errors (error_message, exception)
        """
        self.rtsp_url = rtsp_url
        self.config = config or RTSPConfig()
        
        # Callbacks
        self._on_connect = on_connect
        self._on_disconnect = on_disconnect
        self._on_frame = on_frame
        self._on_error = on_error
        
        # State
        self._state = ConnectionState.DISCONNECTED
        self._state_lock = threading.Lock()
        self._stop_event = threading.Event()
        self._capture: Optional[cv2.VideoCapture] = None
        self._capture_lock = threading.Lock()
        
        # Frame buffer (circular)
        self._frame_buffer: deque = deque(maxlen=self.config.buffer_size)
        self._buffer_lock = threading.Lock()
        self._frame_available = threading.Event()
        
        # Statistics
        self._stats = StreamStats()
        self._stats_lock = threading.Lock()
        self._fps_timestamps: deque = deque(maxlen=self.config.fps_window_size)
        self._decode_times: deque = deque(maxlen=100)
        
        # Reconnection state
        self._current_reconnect_delay = self.config.initial_reconnect_delay
        self._reconnect_attempts = 0
        self._current_protocol_index = 0
        self._current_backend_index = 0
        
        # Health monitoring
        self._last_successful_frame_time = 0.0
        self._consecutive_failures = 0
        self._last_frame_hash: Optional[str] = None
        self._frozen_frame_count = 0
        
        # Connection start time
        self._connection_start_time = 0.0
        
        # Threads
        self._reader_thread: Optional[threading.Thread] = None
        self._health_thread: Optional[threading.Thread] = None
        
        # Setup logging
        self._setup_logging()
        
        self.logger.info(f"Initialized RobustRTSPReader for: {self._sanitize_url(rtsp_url)}")
    
    def _setup_logging(self):
        """Setup logging with optional file rotation."""
        self.logger = logging.getLogger(f"RTSPReader-{id(self)}")
        self.logger.setLevel(self.config.log_level)
        self.logger.handlers.clear()
        
        # Console handler
        console_handler = logging.StreamHandler()
        console_handler.setLevel(self.config.log_level)
        formatter = logging.Formatter(
            '%(asctime)s | %(levelname)-8s | %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        )
        console_handler.setFormatter(formatter)
        self.logger.addHandler(console_handler)
        
        # File handler (optional)
        if self.config.log_file:
            os.makedirs(os.path.dirname(self.config.log_file) or '.', exist_ok=True)
            file_handler = RotatingFileHandler(
                self.config.log_file,
                maxBytes=self.config.log_max_bytes,
                backupCount=self.config.log_backup_count
            )
            file_handler.setLevel(self.config.log_level)
            file_handler.setFormatter(formatter)
            self.logger.addHandler(file_handler)
    
    def _sanitize_url(self, url: str) -> str:
        """Remove credentials from URL for safe logging."""
        if '@' in url:
            # Hide password in URL like rtsp://user:pass@host/path
            parts = url.split('@')
            protocol_user = parts[0]
            host_path = '@'.join(parts[1:])
            if ':' in protocol_user.split('://')[-1]:
                protocol = protocol_user.split('://')[0]
                user = protocol_user.split('://')[1].split(':')[0]
                return f"{protocol}://{user}:****@{host_path}"
        return url
    
    def _set_state(self, new_state: ConnectionState):
        """Thread-safe state transition."""
        with self._state_lock:
            old_state = self._state
            self._state = new_state
            with self._stats_lock:
                self._stats.current_state = new_state
        
        if old_state != new_state:
            self.logger.info(f"State: {old_state.value} -> {new_state.value}")
    
    def _get_state(self) -> ConnectionState:
        """Thread-safe state getter."""
        with self._state_lock:
            return self._state
    
    def _build_capture_options(self, backend: int, protocol: TransportProtocol) -> Dict[str, Any]:
        """Build OpenCV VideoCapture options."""
        options = {
            cv2.CAP_PROP_OPEN_TIMEOUT_MSEC: int(self.config.connection_timeout * 1000),
            cv2.CAP_PROP_READ_TIMEOUT_MSEC: int(self.config.read_timeout * 1000),
            cv2.CAP_PROP_BUFFERSIZE: 1,  # Minimize internal buffering for low latency
        }
        return options
    
    def _get_rtsp_url_with_transport(self, protocol: TransportProtocol) -> str:
        """Modify RTSP URL to force transport protocol."""
        url = self.rtsp_url
        
        # Remove any existing transport parameter
        if '?' in url:
            base_url = url.split('?')[0]
            params = url.split('?')[1]
            # Remove rtsp_transport parameter if exists
            param_list = [p for p in params.split('&') if not p.startswith('rtsp_transport')]
            if param_list:
                url = f"{base_url}?{'&'.join(param_list)}"
            else:
                url = base_url
        
        return url
    
    def _get_gstreamer_pipeline(self, protocol: TransportProtocol, use_gpu: bool = False) -> str:
        """Build GStreamer pipeline string for RTSP with CPU or GPU decoding."""
        transport = "tcp" if protocol == TransportProtocol.TCP else "udp"
        
        # Base RTSP source
        pipeline_base = (
            f'rtspsrc location="{self.rtsp_url}" '
            f'latency=0 '
            f'protocols={transport} '
            f'timeout={int(self.config.connection_timeout * 1000000)} '  # microseconds
            f'tcp-timeout={int(self.config.connection_timeout * 1000000)} '
            f'retry=5 '
            f'do-retransmission=true '
            f'! queue max-size-buffers=1 leaky=downstream '
            f'! rtph264depay '
            f'! h264parse '
        )
        
        if use_gpu:
            # NVIDIA GPU decoding pipeline (NVDEC)
            # Works with NVIDIA GPUs that have hardware video decoder
            gpu_id = self.config.gpu_device_id
            pipeline_decode = (
                f'! nvv4l2decoder gpu-id={gpu_id} '
                f'! nvvideoconvert gpu-id={gpu_id} '
                f'! video/x-raw,format=BGRx '
                f'! videoconvert '
                f'! video/x-raw,format=BGR '
            )
        else:
            # CPU software decoding pipeline
            pipeline_decode = (
                f'! avdec_h264 '
                f'! videoconvert '
                f'! video/x-raw,format=BGR '
            )
        
        # Output sink
        pipeline_sink = f'! appsink drop=true max-buffers=1 sync=false'
        
        return pipeline_base + pipeline_decode + pipeline_sink
    
    def _check_gpu_available(self) -> Tuple[bool, str]:
        """Check if NVIDIA GPU with NVDEC is available."""
        try:
            # Try to detect NVIDIA GPU
            import subprocess
            result = subprocess.run(
                ['nvidia-smi', '--query-gpu=name', '--format=csv,noheader,nounits'],
                capture_output=True,
                text=True,
                timeout=5
            )
            if result.returncode == 0 and result.stdout.strip():
                gpu_name = result.stdout.strip().split('\n')[0]
                self.logger.info(f"NVIDIA GPU detected: {gpu_name}")
                return True, gpu_name
        except FileNotFoundError:
            self.logger.debug("nvidia-smi not found, GPU not available")
        except subprocess.TimeoutExpired:
            self.logger.debug("nvidia-smi timeout")
        except Exception as e:
            self.logger.debug(f"GPU detection error: {e}")
        
        return False, ""
    
    def _determine_decoding_mode(self) -> Tuple[bool, str]:
        """Determine whether to use GPU or CPU decoding based on config and availability."""
        mode = self.config.decoding_mode
        
        if mode == DecodingMode.CPU:
            self.logger.info("Decoding mode: CPU (forced)")
            return False, ""
        
        if mode == DecodingMode.GPU or mode == DecodingMode.AUTO:
            gpu_available, gpu_name = self._check_gpu_available()
            
            if gpu_available:
                self.logger.info(f"Decoding mode: GPU ({gpu_name})")
                return True, gpu_name
            elif mode == DecodingMode.GPU and self.config.force_gpu:
                raise RuntimeError("GPU decoding requested but no NVIDIA GPU available")
            else:
                self.logger.info("Decoding mode: CPU (GPU not available)")
                return False, ""
        
        return False, ""

    
    def _create_capture(self) -> Optional[cv2.VideoCapture]:
        """Create VideoCapture with current backend and protocol settings."""
        all_protocols = [self.config.preferred_protocol] + self.config.fallback_protocols
        all_backends = [self.config.preferred_backend] + self.config.fallback_backends
        
        # Determine GPU or CPU decoding mode
        try:
            use_gpu, gpu_name = self._determine_decoding_mode()
        except RuntimeError as e:
            self.logger.error(str(e))
            return None
        
        # Store decoding mode in stats
        with self._stats_lock:
            self._stats.decoding_mode = "gpu" if use_gpu else "cpu"
            self._stats.gpu_name = gpu_name
        
        # Try each combination of backend and protocol
        for backend_idx, backend in enumerate(all_backends):
            for protocol_idx, protocol in enumerate(all_protocols):
                self.logger.info(
                    f"Trying backend={self._get_backend_name(backend)}, "
                    f"protocol={protocol.value}, "
                    f"decoding={'GPU' if use_gpu else 'CPU'}"
                )
                
                try:
                    cap = self._try_create_capture(backend, protocol, use_gpu)
                    if cap is not None and cap.isOpened():
                        # Verify we can actually read a frame
                        ret, test_frame = cap.read()
                        if ret and test_frame is not None:
                            self._current_backend_index = backend_idx
                            self._current_protocol_index = protocol_idx
                            
                            with self._stats_lock:
                                self._stats.backend_used = self._get_backend_name(backend)
                                self._stats.protocol_used = protocol.value
                            
                            decode_mode_str = f"GPU ({gpu_name})" if use_gpu else "CPU"
                            self.logger.info(
                                f"Successfully connected using "
                                f"{self._get_backend_name(backend)}/{protocol.value} [{decode_mode_str}]"
                            )
                            
                            # Put the test frame in buffer
                            self._process_frame(test_frame)
                            return cap
                        else:
                            self.logger.warning(
                                f"Connected but failed to read frame with "
                                f"{self._get_backend_name(backend)}/{protocol.value}"
                            )
                            cap.release()
                            
                except Exception as e:
                    self.logger.warning(
                        f"Failed with {self._get_backend_name(backend)}/{protocol.value}: {e}"
                    )
                    # If GPU failed, try falling back to CPU
                    if use_gpu and backend == cv2.CAP_GSTREAMER:
                        self.logger.info("GPU decode failed, falling back to CPU...")
                        use_gpu = False
                        with self._stats_lock:
                            self._stats.decoding_mode = "cpu"
                            self._stats.gpu_name = ""
        
        return None
    
    def _try_create_capture(self, backend: int, protocol: TransportProtocol, use_gpu: bool = False) -> Optional[cv2.VideoCapture]:
        """Attempt to create capture with specific backend, protocol, and GPU/CPU mode."""
        try:
            if backend == cv2.CAP_GSTREAMER:
                # Use GStreamer pipeline with GPU or CPU decoding
                pipeline = self._get_gstreamer_pipeline(protocol, use_gpu=use_gpu)
                self.logger.debug(f"GStreamer pipeline: {pipeline}")
                cap = cv2.VideoCapture(pipeline, cv2.CAP_GSTREAMER)
            else:
                # Use FFmpeg backend with environment variables for RTSP options
                url = self._get_rtsp_url_with_transport(protocol)
                
                # Set FFmpeg options via environment (works with some OpenCV builds)
                rtsp_transport = "tcp" if protocol == TransportProtocol.TCP else "udp"
                os.environ['OPENCV_FFMPEG_CAPTURE_OPTIONS'] = (
                    f'rtsp_transport;{rtsp_transport}|'
                    f'stimeout;{int(self.config.connection_timeout * 1000000)}|'
                    f'timeout;{int(self.config.read_timeout * 1000000)}|'
                    f'fflags;nobuffer|'
                    f'flags;low_delay|'
                    f'framedrop;1|'
                    f'max_delay;0'
                )
                
                cap = cv2.VideoCapture(url, backend)
                
                # Apply additional properties
                options = self._build_capture_options(backend, protocol)
                for prop, value in options.items():
                    try:
                        cap.set(prop, value)
                    except Exception:
                        pass  # Some properties may not be supported
            
            return cap
            
        except Exception as e:
            self.logger.warning(f"Exception creating capture: {e}")
            return None
    
    def _get_backend_name(self, backend: int) -> str:
        """Get human-readable backend name."""
        backend_names = {
            cv2.CAP_FFMPEG: "FFmpeg",
            cv2.CAP_GSTREAMER: "GStreamer",
            cv2.CAP_ANY: "Auto",
        }
        return backend_names.get(backend, f"Unknown({backend})")
    
    def _process_frame(self, frame: np.ndarray):
        """Process and buffer a received frame."""
        current_time = time.time()
        
        # Calculate frame hash for frozen detection
        frame_hash = hashlib.md5(
            cv2.resize(frame, (32, 32)).tobytes()
        ).hexdigest()
        
        if frame_hash == self._last_frame_hash:
            self._frozen_frame_count += 1
        else:
            self._frozen_frame_count = 0
            self._last_frame_hash = frame_hash
        
        # Update FPS tracking
        self._fps_timestamps.append(current_time)
        
        # Update statistics
        with self._stats_lock:
            self._stats.frames_received += 1
            self._stats.last_frame_time = current_time
            
            # Calculate FPS
            if len(self._fps_timestamps) >= 2:
                time_span = self._fps_timestamps[-1] - self._fps_timestamps[0]
                if time_span > 0:
                    self._stats.fps = (len(self._fps_timestamps) - 1) / time_span
        
        # Buffer frame
        with self._buffer_lock:
            if len(self._frame_buffer) >= self.config.buffer_size:
                if self.config.drop_frames_when_full:
                    # Drop oldest frame
                    with self._stats_lock:
                        self._stats.frames_dropped += 1
            
            self._frame_buffer.append((frame.copy(), current_time))
            self._frame_available.set()
        
        # Callback
        if self._on_frame:
            try:
                self._on_frame(frame, self.get_stats())
            except Exception as e:
                self.logger.error(f"Error in on_frame callback: {e}")
        
        self._last_successful_frame_time = current_time
        self._consecutive_failures = 0
    
    def _reader_loop(self):
        """Main reading loop running in separate thread."""
        self.logger.info("Reader thread started")
        
        while not self._stop_event.is_set():
            state = self._get_state()
            
            if state in (ConnectionState.DISCONNECTED, ConnectionState.RECONNECTING):
                self._attempt_connection()
            
            elif state == ConnectionState.CONNECTED:
                self._read_frames()
            
            elif state == ConnectionState.ERROR:
                # Wait before retry
                self._wait_with_backoff()
                self._set_state(ConnectionState.RECONNECTING)
            
            else:  # STOPPED
                break
        
        self.logger.info("Reader thread stopped")
    
    def _attempt_connection(self):
        """Attempt to establish connection."""
        self._set_state(ConnectionState.CONNECTING)
        
        self.logger.info(
            f"Attempting connection (attempt #{self._reconnect_attempts + 1})"
        )
        
        with self._capture_lock:
            if self._capture is not None:
                try:
                    self._capture.release()
                except:
                    pass
                self._capture = None
            
            self._capture = self._create_capture()
        
        if self._capture is not None and self._capture.isOpened():
            self._set_state(ConnectionState.CONNECTED)
            self._connection_start_time = time.time()
            self._current_reconnect_delay = self.config.initial_reconnect_delay
            self._reconnect_attempts = 0
            
            with self._stats_lock:
                self._stats.reconnect_count += 1
                self._stats.last_error = ""
            
            self.logger.info("Connection established successfully")
            
            if self._on_connect:
                try:
                    self._on_connect()
                except Exception as e:
                    self.logger.error(f"Error in on_connect callback: {e}")
        else:
            self._handle_connection_failure("Failed to establish connection")
    
    def _read_frames(self):
        """Read frames from connected stream."""
        with self._capture_lock:
            if self._capture is None or not self._capture.isOpened():
                self._handle_connection_failure("Capture became invalid")
                return
            
            try:
                start_time = time.time()
                ret, frame = self._capture.read()
                decode_time = time.time() - start_time
                
                if ret and frame is not None and frame.size > 0:
                    self._decode_times.append(decode_time)
                    with self._stats_lock:
                        if len(self._decode_times) > 0:
                            self._stats.avg_frame_decode_time = sum(self._decode_times) / len(self._decode_times)
                    
                    self._process_frame(frame)
                else:
                    self._consecutive_failures += 1
                    self.logger.debug(
                        f"Frame read failed (consecutive: {self._consecutive_failures})"
                    )
                    
                    if self._consecutive_failures >= self.config.max_consecutive_failures:
                        self._handle_connection_failure(
                            f"Too many consecutive frame failures: {self._consecutive_failures}"
                        )
                    else:
                        time.sleep(0.01)  # Brief pause before retry
                        
            except Exception as e:
                self._handle_connection_failure(f"Exception reading frame: {e}")
    
    def _handle_connection_failure(self, reason: str):
        """Handle connection failure with state transition."""
        self.logger.warning(f"Connection failure: {reason}")
        
        with self._stats_lock:
            self._stats.last_error = reason
        
        with self._capture_lock:
            if self._capture is not None:
                try:
                    self._capture.release()
                except:
                    pass
                self._capture = None
        
        self._reconnect_attempts += 1
        
        # Check if we should continue reconnecting
        if not self.config.infinite_reconnect:
            if self._reconnect_attempts >= self.config.max_reconnect_attempts:
                self._set_state(ConnectionState.ERROR)
                self.logger.error(
                    f"Max reconnect attempts ({self.config.max_reconnect_attempts}) reached"
                )
                
                if self._on_error:
                    try:
                        self._on_error(reason, None)
                    except:
                        pass
                return
        
        if self._on_disconnect:
            try:
                self._on_disconnect()
            except Exception as e:
                self.logger.error(f"Error in on_disconnect callback: {e}")
        
        self._set_state(ConnectionState.RECONNECTING)
        self._wait_with_backoff()
    
    def _wait_with_backoff(self):
        """Wait with exponential backoff before reconnection."""
        delay = self._current_reconnect_delay
        self.logger.info(f"Waiting {delay:.1f}s before reconnection attempt...")
        
        # Wait but check for stop event
        start_wait = time.time()
        while (time.time() - start_wait) < delay:
            if self._stop_event.is_set():
                return
            time.sleep(0.1)
        
        # Increase delay for next time (exponential backoff)
        self._current_reconnect_delay = min(
            self._current_reconnect_delay * self.config.reconnect_multiplier,
            self.config.max_reconnect_delay
        )
    
    def _health_check_loop(self):
        """Health monitoring loop."""
        self.logger.info("Health check thread started")
        
        while not self._stop_event.is_set():
            try:
                self._perform_health_check()
            except Exception as e:
                self.logger.error(f"Health check error: {e}")
            
            # Wait for next check
            self._stop_event.wait(self.config.health_check_interval)
        
        self.logger.info("Health check thread stopped")
    
    def _perform_health_check(self):
        """Perform stream health check."""
        state = self._get_state()
        
        if state != ConnectionState.CONNECTED:
            return
        
        current_time = time.time()
        
        # Check for stale stream (no frames received)
        time_since_frame = current_time - self._last_successful_frame_time
        if self._last_successful_frame_time > 0 and time_since_frame > self.config.stale_frame_timeout:
            self.logger.warning(
                f"Stale stream detected: {time_since_frame:.1f}s since last frame"
            )
            self._handle_connection_failure("Stream appears stale (no new frames)")
            return
        
        # Check for frozen frames
        if self._frozen_frame_count > 30:  # ~1 second of identical frames at 30fps
            self.logger.warning(
                f"Frozen stream detected: {self._frozen_frame_count} identical frames"
            )
            # Reset counter but don't disconnect (could be static scene)
            self._frozen_frame_count = 0
        
        # Update connection uptime
        if self._connection_start_time > 0:
            with self._stats_lock:
                self._stats.connection_uptime = current_time - self._connection_start_time
    
    def start(self) -> 'RobustRTSPReader':
        """
        Start the RTSP reader (non-blocking).
        
        Returns:
            self for method chaining
        """
        if self._reader_thread is not None and self._reader_thread.is_alive():
            self.logger.warning("Reader already running")
            return self
        
        self.logger.info("Starting RTSP reader...")
        
        self._stop_event.clear()
        self._set_state(ConnectionState.DISCONNECTED)
        
        # Start reader thread
        self._reader_thread = threading.Thread(
            target=self._reader_loop,
            name="RTSPReader",
            daemon=True
        )
        self._reader_thread.start()
        
        # Start health check thread
        self._health_thread = threading.Thread(
            target=self._health_check_loop,
            name="RTSPHealthCheck",
            daemon=True
        )
        self._health_thread.start()
        
        return self
    
    def stop(self, timeout: float = 5.0):
        """
        Stop the RTSP reader gracefully.
        
        Args:
            timeout: Maximum time to wait for threads to stop
        """
        self.logger.info("Stopping RTSP reader...")
        
        self._stop_event.set()
        self._set_state(ConnectionState.STOPPED)
        
        # Wait for threads
        if self._reader_thread is not None:
            self._reader_thread.join(timeout=timeout)
        if self._health_thread is not None:
            self._health_thread.join(timeout=timeout)
        
        # Release capture
        with self._capture_lock:
            if self._capture is not None:
                try:
                    self._capture.release()
                except:
                    pass
                self._capture = None
        
        self.logger.info("RTSP reader stopped")
    
    def get_frame(self, timeout: Optional[float] = None) -> Optional[np.ndarray]:
        """
        Get the latest frame from the buffer (thread-safe).
        
        Args:
            timeout: Maximum time to wait for a frame (None = non-blocking)
        
        Returns:
            Frame as numpy array or None if no frame available
        """
        if timeout is not None:
            self._frame_available.wait(timeout=timeout)
        
        with self._buffer_lock:
            if len(self._frame_buffer) > 0:
                frame, timestamp = self._frame_buffer[-1]  # Get latest
                self._frame_buffer.clear()  # Clear old frames
                self._frame_available.clear()
                return frame
        
        return None
    
    def get_all_frames(self) -> list:
        """
        Get all buffered frames (drains the buffer).
        
        Returns:
            List of (frame, timestamp) tuples
        """
        with self._buffer_lock:
            frames = list(self._frame_buffer)
            self._frame_buffer.clear()
            self._frame_available.clear()
            return frames
    
    def get_stats(self) -> StreamStats:
        """Get current stream statistics."""
        with self._stats_lock:
            return StreamStats(
                fps=self._stats.fps,
                frames_received=self._stats.frames_received,
                frames_dropped=self._stats.frames_dropped,
                reconnect_count=self._stats.reconnect_count,
                last_frame_time=self._stats.last_frame_time,
                connection_uptime=self._stats.connection_uptime,
                bytes_received=self._stats.bytes_received,
                avg_frame_decode_time=self._stats.avg_frame_decode_time,
                current_state=self._stats.current_state,
                last_error=self._stats.last_error,
                backend_used=self._stats.backend_used,
                protocol_used=self._stats.protocol_used,
            )
    
    def is_connected(self) -> bool:
        """Check if currently connected to stream."""
        return self._get_state() == ConnectionState.CONNECTED
    
    def is_running(self) -> bool:
        """Check if reader is running (may not be connected)."""
        state = self._get_state()
        return state not in (ConnectionState.STOPPED, ConnectionState.ERROR)
    
    def draw_stats_overlay(self, frame: np.ndarray) -> np.ndarray:
        """
        Draw statistics overlay on frame.
        
        Args:
            frame: Input frame
        
        Returns:
            Frame with overlay
        """
        stats = self.get_stats()
        
        overlay = frame.copy()
        height, width = frame.shape[:2]
        
        # Semi-transparent background
        cv2.rectangle(overlay, (10, 10), (350, 160), (0, 0, 0), -1)
        frame = cv2.addWeighted(overlay, 0.7, frame, 0.3, 0)
        
        # Stats text
        y_offset = 30
        line_height = 25
        font = cv2.FONT_HERSHEY_SIMPLEX
        font_scale = 0.6
        color = (0, 255, 0) if stats.current_state == ConnectionState.CONNECTED else (0, 0, 255)
        
        lines = [
            f"State: {stats.current_state.value.upper()}",
            f"FPS: {stats.fps:.1f}",
            f"Frames: {stats.frames_received} (dropped: {stats.frames_dropped})",
            f"Reconnects: {stats.reconnect_count}",
            f"Backend: {stats.backend_used}/{stats.protocol_used}",
            f"Decode: {stats.decoding_mode.upper()}" + (f" ({stats.gpu_name})" if stats.gpu_name else ""),
        ]
        
        if stats.last_error:
            lines.append(f"Error: {stats.last_error[:30]}...")
        
        for line in lines:
            cv2.putText(frame, line, (20, y_offset), font, font_scale, color, 2)
            y_offset += line_height
        
        return frame
    
    def __enter__(self):
        """Context manager enter."""
        self.start()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit."""
        self.stop()
        return False


# Export main classes for easy importing
__all__ = [
    'RobustRTSPReader',
    'RTSPConfig', 
    'ConnectionState',
    'TransportProtocol',
    'DecodingMode',
    'StreamStats'
]


